# P1 模式语义偏差：dual_verify / complementary 模式实现与设计不一致

**严重等级**: P1（双模式/组合模式的语义偏差，影响非默认模式的信号质量）
**影响范围**: `integration_mode ∈ {dual_verify, complementary}` 的输出

---

## P1-1：dual_verify 模式缺少 consensus_factor 调整

### 问题描述

设计定义了 dual_verify 模式基于 TD/BU 方向共识的精细调整机制，代码仅实现了"矛盾时设为 HOLD"的粗粒度处理。

### 设计原文

> integration-algorithm.md §10.5.1:
> ```
> 3. 方向共识判定：
>    td_direction = direction_from(td_result)
>    bu_direction = direction_from(bu_result)
>    consensus = td_direction + bu_direction
>
>    - |consensus| == 2 → 强共识，consensus_factor = 1.0
>    - |consensus| == 1 → 弱共识，consensus_factor = 0.9
>    - consensus == 0 且 td ≠ bu → 矛盾，consensus_factor = 0.7，recommendation 上限 HOLD
>    - consensus == 0 且 td == bu == 0 → 双中性，consensus_factor = 1.0，recommendation 上限 HOLD
>
> 4. 最终调整：
>    final_score *= consensus_factor
>    position_size = min(td_result.position_size, bu_result.position_size)
>    neutrality = max(td_result.neutrality, bu_result.neutrality) × consensus_factor
> ```

### 代码现状

```python
# src/integration/pipeline.py line 931-936
elif resolved_integration_mode == "dual_verify":
    final_score = round((top_down_score + bottom_up_score) / 2.0, 4)
    recommendation = _to_recommendation(final_score, mss_cycle)
    if td_direction != bu_direction and td_direction != "neutral" and bu_direction != "neutral":
        recommendation = "HOLD"
    mode_position_cap = min(cycle_position_cap_top_down, cycle_position_cap_bottom_up)
```

缺失：
1. **consensus_factor 未乘入 final_score** — 弱共识场景（一方中性一方有方向）不会削弱评分（设计要求 ×0.9）
2. **矛盾场景 final_score 未乘 0.7** — 只降了 recommendation 到 HOLD，但 final_score 未变
3. **双中性场景** — 设计要求 recommendation 上限 HOLD，代码未特判

### 具体后果

dual_verify 模式中，当 TD 看多 + BU 中性（弱共识）时：
- 按设计：final_score 应被削弱 10%（×0.9）
- 按代码：final_score 不变

当 TD 看多 + BU 看空（矛盾）时：
- 按设计：final_score × 0.7 + recommendation 上限 HOLD
- 按代码：final_score 不变 + recommendation 设为 HOLD

### 修复方案

**方案 A（修代码 — 推荐）**：

修复要点：
1. 计算数值化 TD/BU 方向（+1/0/-1）
2. 按设计规则确定 consensus_factor（1.0 / 0.9 / 0.7）
3. `final_score *= consensus_factor`
4. 矛盾/双中性时 recommendation 上限 HOLD
5. position_size 取 min(td_position, bu_position)（当前用周期 cap 的 min，应改为实际仓位的 min）

**方案 B（改设计为当前简化口径）**：将 consensus_factor 机制简化为"矛盾→HOLD，其余不调整"，文档标注为 MVP 简化。

### 涉及文件

- `src/integration/pipeline.py` — dual_verify 分支

---

## P1-2：dual_verify 模式 position_size 语义偏差

### 问题描述

设计要求 position_size 取两条链路实际仓位的较小值（保守原则），代码取的是两条链路周期上限的较小值。

### 设计原文

> integration-algorithm.md §10.5.1:
> `position_size = min(td_result.position_size, bu_result.position_size)`

### 代码现状

```python
# src/integration/pipeline.py line 936
mode_position_cap = min(cycle_position_cap_top_down, cycle_position_cap_bottom_up)
```

后续（line 951-954）position_size 是 `min(base_position_size, position_cap)` 而非 `min(td_position, bu_position)`。

### 具体后果

设计中 td 和 bu 各自独立计算的 position_size 可能差异很大（比如 TD=0.30, BU=0.65），取 min 应为 0.30。但代码中 position_size 是统一从 final_score 推出的单一值，无法实现两路独立仓位再取 min 的逻辑。

这个差异源于代码架构——代码在每只股票的循环中同时计算 TD/BU 分数，但只产出单一 position_size，而设计假设 TD 和 BU 各自产出完整的仓位建议。

### 修复方案

**方案 A（修代码）**：在 dual_verify 分支中分别计算 td_position_size 和 bu_position_size，然后取 min。这需要在主循环内部新增 TD/BU 各自的仓位计算逻辑。

**方案 B（改设计 — 推荐此差异用方案B）**：文档说明当前实现使用"周期 cap min + 统一 base_position"作为 MVP 简化，保留"两路独立仓位取 min"为未来优化方向。

### 涉及文件

- `src/integration/pipeline.py`

---

## P1-3：complementary 模式评分来源偏差

### 问题描述

设计要求 complementary 模式使用 TD 评分作为最终评分（TD 负责风控框架），代码使用 TD/BU 的 40/60 加权平均，且 BU 权重更高。

### 设计原文

> integration-algorithm.md §10.5.2:
> ```
> 3. 组合构建：
>    - final_score = td_result.final_score          # 使用 TD 评分（风控口径）
>    - recommendation = td_result.recommendation    # 使用 TD 推荐等级
>    - position_size = td_result.position_size      # 使用 TD 仓位
>    - selected_stocks 从 bu_candidates 中按 BU 排序选取
> ```
>
> 验收口径：
> - 总仓位 ≤ TD 计算的 position_size（铁律：BU 不突破 TD 上限）
> - 标的排序来自 BU

### 代码现状

```python
# src/integration/pipeline.py line 937-942
else:  # complementary
    final_score = round(top_down_score * 0.40 + bottom_up_score * 0.60, 4)
    recommendation = _to_recommendation(final_score, mss_cycle)
    if td_direction != bu_direction and td_direction != "neutral" and bu_direction != "neutral":
        recommendation = "HOLD"
    mode_position_cap = cycle_position_cap_top_down
```

关键差异：
1. **评分来源**：设计用 `td_result.final_score`，代码用 `td*0.40 + bu*0.60`
2. **推荐等级来源**：设计用 `td_result.recommendation`，代码从混合 final_score 重新派生
3. **BU 权重 60% > TD 权重 40%**：这与设计中"TD 确定风控框架"的定位矛盾——BU 反而主导了评分

### 具体后果

complementary 模式的设计意图是"TD 做风控框架，BU 做选股排序"，但代码实现成了"BU 主导评分的加权融合"，本质上变成了一个偏 BU 的 dual_verify。

例：td_score=50（HOLD），bu_score=85（BUY）时：
- 按设计：final_score=50 → HOLD（TD 风控口径）
- 按代码：final_score=50×0.4+85×0.6=71 → BUY（BU 主导）

### 修复方案

**方案 A（修代码 — 推荐）**：

修复要点：
1. `final_score = top_down_score`（使用 TD 评分）
2. `recommendation = td_recommendation`（使用 TD 推荐等级）
3. 保留 `mode_position_cap = cycle_position_cap_top_down`（TD 仓位上限）
4. BU 的作用体现在推荐列表的排序上（已有 opportunity_grade 排序）

**方案 B（改设计）**：如果 40/60 加权的代码行为更合理，则设计 §10.5.2 需要重写为"加权融合"模式而非"TD 风控 + BU 选股"的互补架构。

### 涉及文件

- `src/integration/pipeline.py` — complementary 分支
