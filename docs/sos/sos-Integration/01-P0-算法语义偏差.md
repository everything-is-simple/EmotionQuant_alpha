# P0 算法语义偏差：核心算法公式/逻辑与设计相悖

**严重等级**: P0（直接影响 final_score / recommendation / position_size / neutrality 正确性）
**影响范围**: integrated_recommendation 全部输出 → 交易信号链路

---

## P0-1：strength_factor（多数一致约束）未应用于 final_score

### 问题描述

设计明确要求方向一致性影响最终评分，但代码计算了 consistency 标签后并未将其作用于 final_score。

### 设计原文

> integration-algorithm.md §5.2:
> - consistency = consistent → strength_factor = 1.0
> - consistency = partial → strength_factor = 0.9
> - consistency = divergent → strength_factor = 0.8
>
> §5.3 协同约束执行顺序（第4步）:
> `final_score *= strength_factor`

### 代码现状

```python
# src/integration/pipeline.py line 944-945
direction = _to_direction(mss_direction, irs_direction, pas_direction)
consistency = _to_consistency(mss_direction, irs_direction, pas_direction)
# ← 到此为止，consistency 仅作为标签记录，从未乘入 final_score
```

`_to_consistency()` 返回 "consistent"/"partial"/"divergent" 字符串，但主循环中没有任何代码将其转换为数值系数并乘入 final_score。

### 具体后果

当三系统方向分歧（divergent）时：
- 按设计：final_score 应被削弱 20%（×0.8）
- 按代码：final_score 不变

例：top_down_score=72 + divergent → 设计应为 72×0.8=57.6（→HOLD），代码仍为 72（→BUY）。
方向分歧时的信号强度没有被削弱，可能产生错误的积极买入信号。

### 修复方案

**方案 A（修代码 — 推荐）**：在 top_down_score 和 bottom_up_score 计算之后、赋值 final_score 之前，乘以 strength_factor。

修复要点：
1. 新增映射函数：
```python
def _strength_factor(consistency: str) -> float:
    return {"consistent": 1.0, "partial": 0.9, "divergent": 0.8}.get(consistency, 1.0)
```
2. 在主循环中 direction/consistency 计算完成后（约 line 944-945），对所有模式的 final_score 统一乘以 strength_factor
3. 注意：strength_factor 必须在协同约束（IRS pas_score 调整）之后、信号生成之前应用
4. 更新相关契约测试

**方案 B（改设计）**：如果认为代码的"不削弱"更合理，则需删除设计中 §5.2 的 strength_factor 及 §5.3 第4步。

### 涉及文件

- `src/integration/pipeline.py` — 主修改
- `tests/unit/integration/test_algorithm_semantics_regression.py` — 验证

---

## P0-2：IRS 方向映射来源错误（rotation_status vs recommendation）

### 问题描述

设计要求 IRS 方向从 `rotation_status`（IN/OUT/HOLD）映射，代码从 IRS 的 `recommendation`（STRONG_BUY/BUY/HOLD/SELL/AVOID）映射。

### 设计原文

> integration-algorithm.md §4.1 方向映射表:
> | IRS状态 | 方向代码 |
> | IN      | +1（看涨） |
> | OUT     | -1（看跌） |
> | HOLD    | 0（中性）  |

### 代码现状

```python
# src/integration/pipeline.py line 878
irs_direction = _direction_from_recommendation(irs_recommendation)

# _direction_from_recommendation 定义（line 239-245）
def _direction_from_recommendation(recommendation: str) -> str:
    if value in {RecommendationGrade.STRONG_BUY, RecommendationGrade.BUY}:
        return PasDirection.BULLISH
    if value in {RecommendationGrade.SELL, RecommendationGrade.AVOID}:
        return PasDirection.BEARISH
    return PasDirection.NEUTRAL
```

而代码读取 IRS 数据时（line 633）查询的列中包含 `recommendation` 但**不包含 `rotation_status`**。

### 具体后果

一个行业 rotation_status=IN（正在轮入）但 recommendation=HOLD（中性推荐）的场景：
- 按设计：irs_direction = +1（看涨）
- 按代码：irs_direction = 0（中性）

这会导致方向一致性检查产生不同的 consistency 判定（如本应 consistent 变为 partial）。

### 修复方案

**方案 A（修代码 — 推荐）**：

修复要点：
1. 在 IRS 查询中增加 `rotation_status` 列
2. 新增映射函数：
```python
def _direction_from_rotation_status(rotation_status: str) -> str:
    mapping = {"IN": "bullish", "OUT": "bearish", "HOLD": "neutral"}
    return mapping.get(str(rotation_status).strip().upper(), "neutral")
```
3. 将 line 878 改为使用 `_direction_from_rotation_status(rotation_status)`
4. 若 `rotation_status` 列不存在（兼容性），回退到当前 recommendation 映射

**方案 B（改设计）**：如果 IRS 实际不输出 rotation_status，而是用 recommendation 表达方向，则设计 §4.1 方向映射表需改为以 recommendation 为来源。

### 涉及文件

- `src/integration/pipeline.py` — 主修改（IRS 查询 + 方向映射）
- 需确认 `irs_industry_daily` 表是否有 `rotation_status` 列

---

## P0-3：仓位计算公式严重简化（缺失三类调整因子）

### 问题描述

设计定义了基于 MSS温度/IRS配置/PAS等级 三类乘子的精细仓位计算，代码仅做了粗粒度的温度极端判断和 cap 约束。

### 设计原文

> integration-algorithm.md §6.1:
> ```
> 最终仓位 = base_position × mss_factor × irs_factor × pas_factor × position_cap_ratio
>
> mss_factor = 1 - |temperature - 50| / 100
> irs_factor: 超配×1.2, 标配×1.0, 减配×0.7, 回避×0.3
> pas_factor: S×1.2, A×1.0, B×0.7, C/D×0.3
> ```

### 代码现状

```python
# src/integration/pipeline.py line 948-954
base_position_size = max(0.0, min(1.0, final_score / 100.0))
if _temp_extreme:                   # mss_temperature < 30 或 > 80
    base_position_size *= 0.85      # 硬编码 0.85，非连续函数
position_cap = min(position_cap_ratio, mode_position_cap)
if _position_cap_warn:
    position_cap = min(position_cap, 0.80)
position_size = round(min(base_position_size, position_cap), 4)
```

三项严重缺失：
1. **MSS温度调整**：设计为连续函数 `1 - |temp-50|/100`（温度=20时factor=0.7，温度=80时factor=0.7），代码为二值判断（极端时固定×0.85，否则×1.0）
2. **IRS配置调整**：超配1.2/标配1.0/减配0.7/回避0.3 — **完全缺失**
3. **PAS等级调整**：S×1.2/A×1.0/B×0.7/C/D×0.3 — **完全缺失**

### 具体后果

一只 C 级股票在回避行业中：
- 按设计：position_size × 0.3(IRS回避) × 0.3(C级) = position_size × 0.09
- 按代码：position_size 没有任何缩减

高风险标的的仓位没有被适当压缩，风控失效。

### 修复方案

**方案 A（修代码 — 推荐）**：

修复要点：
1. 实现连续 MSS 温度因子：`mss_factor = 1.0 - abs(mss_temperature - 50.0) / 100.0`
2. 实现 IRS 配置因子映射（allocation_advice → 乘子）
3. 实现 PAS 等级因子映射（opportunity_grade → 乘子）
4. 仓位公式改为：`position_size = base × mss_factor × irs_factor × pas_factor × position_cap_ratio`
5. 乘子默认值可先硬编码，后续迁移到 regime_parameters

**方案 B（改设计为 MVP 简化版）**：将设计中的精细仓位公式降级为"MVP 简化口径"，标注为未来扩展。

### 涉及文件

- `src/integration/pipeline.py` — 主修改

---

## P0-4：单股仓位上限（per-grade cap）未实现

### 问题描述

设计定义了按 PAS 等级的单股仓位上限，代码未实现。

### 设计原文

> integration-algorithm.md §6.2:
> - S级机会：20%
> - A级机会：15%
> - B级机会：10%
> - C/D级：5%

### 代码现状

代码中 position_size 仅受 `position_cap_ratio` 和 `mode_position_cap` 约束，无任何 per-grade 上限逻辑。

### 具体后果

一只 D 级股票理论上可以获得与 S 级相同的仓位建议，这违反了按信号质量分层风控的设计意图。

### 修复方案

**方案 A（修代码 — 推荐）**：

修复要点：
1. 新增 grade → cap 映射：
```python
GRADE_POSITION_CAP = {"S": 0.20, "A": 0.15, "B": 0.10, "C": 0.05, "D": 0.05}
```
2. 在 position_size 最终计算中增加 `min(position_size, grade_cap)`

**方案 B（改设计）**：如果认为 per-grade cap 是冗余约束（PAS 等级已通过 pas_factor 影响仓位），可在设计中降级为"建议值"。

### 涉及文件

- `src/integration/pipeline.py`

---

## P0-5：中性度计算完全不同（score-based fallback vs 三系统加权）

### 问题描述

设计定义了基于三系统 neutrality 加权均值的综合中性度，并叠加 consistency_factor 和 mss_neutrality_risk_factor。代码使用的是纯 final_score 推导的简化 fallback 公式。

### 设计原文

> integration-algorithm.md §7.1:
> ```
> neutrality = (mss_neut × w_mss + irs_neut × w_irs + pas_neut × w_pas)
>           × consistency_factor
>           × mss_neutrality_risk_factor
> ```
> §7.2: `neutrality = 1 - |score - 50| / 50`（仅在上游未提供 neutrality 时使用的参考口径）

### 代码现状

```python
# src/integration/pipeline.py line 946
neutrality = round(max(0.0, min(1.0, 1.0 - abs(final_score - 50.0) / 50.0)), 4)
```

代码直接使用了 §7.2 的"参考口径"作为唯一计算方式，且：
- 未读取 MSS/IRS/PAS 的 neutrality 字段
- 未应用 consistency_factor
- 未应用 mss_neutrality_risk_factor（温度极端时×1.1）

### 具体后果

中性度计算完全依赖 final_score，丢失了三系统各自 neutrality 蕴含的独立信号质量信息。

例：final_score=70 时，无论三系统方向是否一致、MSS 温度是否极端，neutrality 始终 = 1 - |70-50|/50 = 0.6。而设计中，如果方向分歧（consistency_factor=0.7）且温度极端（risk_factor=1.1），neutrality 会被额外调整。

### 修复方案

**方案 A（修代码 — 分步实现）**：

第1步（最小修复）：即使不读取上游 neutrality，也应将 consistency_factor 和 mss_neutrality_risk_factor 乘入当前 fallback 公式。
第2步（完整修复）：在 MSS/IRS/PAS 查询中增加 neutrality 列的读取，实现设计中的加权均值公式。

**方案 B（改设计为当前实现口径）**：将 §7.1 的加权均值降级为"扩展口径"，§7.2 的 score-based fallback 提升为"MVP 主口径"，但仍需补齐 consistency_factor 和 risk_factor 的应用。

### 涉及文件

- `src/integration/pipeline.py` — 中性度计算
- MSS/IRS/PAS 查询语句 — 增加 neutrality 列

---

## P0-6：IRS "超配" boost 未实现

### 问题描述

设计要求 IRS allocation_advice="超配" 时对 pas_score 上浮（默认×1.05），代码只处理了"回避"折扣。

### 设计原文

> integration-algorithm.md §5.3:
> - IRS allocation_advice = "回避" → pas_score 轻度折扣（默认 0.85）
> - IRS allocation_advice = "超配" → pas_score 轻度上浮（默认 1.05）
> - IRS 约束后必须执行边界裁剪：`pas_score = clip(pas_score, 0, 100)`

### 代码现状

```python
# src/integration/pipeline.py line 895
effective_pas_score = pas_score * (0.85 if allocation_advice == "回避" else 1.0)
# ← "超配" 直接走 else → ×1.0，未上浮
```

### 具体后果

超配行业中的个股不会获得设计中的 5% 评分上浮，与"回避行业折扣"形成不对称的单向约束。这会系统性地低估超配行业的信号强度。

### 修复方案

**方案 A（修代码 — 推荐）**：

修复要点：
1. 扩展 effective_pas_score 计算：
```python
if allocation_advice == "回避":
    effective_pas_score = pas_score * 0.85
elif allocation_advice == "超配":
    effective_pas_score = pas_score * 1.05
else:
    effective_pas_score = pas_score
effective_pas_score = max(0.0, min(100.0, effective_pas_score))  # clip
```
2. 后续可将 0.85/1.05 迁移为 regime_parameters 驱动

### 涉及文件

- `src/integration/pipeline.py`

---

## P0-7：协同约束后 pas_score 未做 clip 边界裁剪

### 问题描述

设计要求 IRS 协同约束调整 pas_score 后必须做 `clip(0, 100)` 边界裁剪，代码缺失此步骤。

### 设计原文

> integration-algorithm.md §5.3 协同约束执行顺序:
> 1) 调整 pas_score
> 2) `pas_score = clip(pas_score, 0, 100)` ← 必须
> 3) final_score = 加权公式
> 4) final_score *= strength_factor

### 代码现状

```python
# src/integration/pipeline.py line 895
effective_pas_score = pas_score * (0.85 if allocation_advice == "回避" else 1.0)
# ← 无 clip，直接用于加权计算
```

### 具体后果

当前仅有"回避"折扣（×0.85），结果不会超出 [0,100]。但如果修复 P0-6 后增加"超配"上浮（×1.05），pas_score=98 × 1.05 = 102.9 会超过 100。此时缺少 clip 会导致 final_score 偏高。

### 修复方案

**方向**：在 P0-6 修复时一并添加 clip。

修复要点：
1. 在 effective_pas_score 赋值后增加 `effective_pas_score = max(0.0, min(100.0, effective_pas_score))`
2. 与 P0-6 合并为一个修复

### 涉及文件

- `src/integration/pipeline.py`
