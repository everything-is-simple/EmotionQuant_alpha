# PAS 急救方案 — 逐项修复与优先级排序

**创建日期**: 2026-02-27
**总体方向**: 以设计 v3.2.0 为准，修订代码；保留代码中的向量化工程架构

---

## 修复批次总览

```
┌─────────────────────────────────────────────────────────────────────┐
│  第一批：数据源补齐（P1-01, P1-02）                                  │
│  ↓ 后续因子计算依赖正确的 turnover_rate 和 limit_up 数据            │
├─────────────────────────────────────────────────────────────────────┤
│  第二批：三因子公式对齐（P0-01 ~ P0-08）                             │
│  ↓ 因子正确后才能输出正确的评分/等级/风险收益                        │
├─────────────────────────────────────────────────────────────────────┤
│  第三批：输出模型补全（P2-01 ~ P2-03）                               │
│  ↓ 主表字段 + 中间表字段 + opportunity_log                           │
├─────────────────────────────────────────────────────────────────────┤
│  第四批：文档与基线（P3-01 ~ P3-02）                                 │
│  ↓ docstring 更新 + baseline parquet 机制                           │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 第一批：数据源补齐

### FIX-P1-01 读取 raw_daily_basic 获取真实 turnover_rate

**问题**: turnover_rate 用 amount/(close×10000) 粗略近似
**修复方向**: 以设计为准，修改代码

**改动要点**:
1. 在 `run_pas_daily()` 的 DuckDB 查询中新增读取 `raw_daily_basic` 表
2. JOIN 字段: `trade_date` + `ts_code` (或 `stock_code`)
3. 提取字段: `turnover_rate`（换手率%），如果有 `total_mv` / `circ_mv` 也可一并提取
4. 用真实 `turnover_rate` 替换 `_tr = _amount / np.maximum(_close * 10000.0, 1.0)`

**代码改动位置**: `pipeline.py:179-202`（数据加载区）和 `pipeline.py:408`（换手率计算）

**降级策略**: 若 `raw_daily_basic` 表不存在或当日数据缺失，回退到当前近似公式并标记 `quality_flag` 告警

**依赖**: 无前置依赖
**风险**: 低 — 仅增加数据读取，不改变计算逻辑

---

### FIX-P1-02 读取 raw_limit_list 获取真实涨跌停状态

**问题**: 涨跌停状态全靠价格阈值推断，两处口径不一致
**修复方向**: 以设计为准，修改代码

**改动要点**:
1. 在 DuckDB 查询中新增读取 `raw_limit_list` 表（当日 + 历史 120 日）
2. 提取/构建字段:
   - `is_limit_up`: 当日是否涨停（布尔）
   - `is_touched_limit_up`: 当日是否触及涨停（含炸板）
   - `limit_up_count_120d`: 近 120 日涨停次数（按 stock_code 聚合）
3. 用真实状态替换 `wpct.ge(_blt_row)` 和 `_pct_today >= _blt`
4. 统一两处涨停判定口径为同一数据源

**代码改动位置**: `pipeline.py:179-202`（数据加载），`pipeline.py:280-282`（牛股基因涨停），`pipeline.py:472-474`（风险折扣涨停）

**降级策略**: 若 `raw_limit_list` 表不存在，回退到当前价格推断逻辑

**依赖**: 无前置依赖
**风险**: 低 — 增加数据源使结果更准确

---

## 第二批：三因子公式对齐

### FIX-P0-01 修正牛股基因因子子权重

**问题**: 子权重 0.4/0.4/0.2 应为 0.4/0.3/0.3
**修复方向**: 以设计为准，修改代码

**改动要点**: 修改 `pipeline.py:292`
```python
# 修改前
wbg = 0.4 * wlur + 0.4 * wnhr + 0.2 * wmaxpct
# 修改后
wbg = 0.4 * wlur + 0.3 * wnhr + 0.3 * wmaxpct
```

**依赖**: FIX-P0-02（max_pct_chg 需要同步修正计算方式，否则权重改了但输入仍不对）
**风险**: 低 — 常量修改

---

### FIX-P0-02 修正 max_pct_chg_history 计算

**问题**: 代码用 rolling(120).max()/0.30 而非设计的 max_pct_chg_history/100
**修复方向**: 以设计为准，修改代码

**改动要点**:
1. 利用已有的 `wpct`（pct_change ratio）数据，取 rolling 120 日最大值
2. 由于 `wpct` 已是 ratio 口径（0.10 = 10%），而设计期望「百分数/100」也是 ratio
3. 关键变化: **去掉 /0.30 的天花板归一化**，改为直接使用 ratio 值
4. 不做 clip(0, 1) — 因为 zscore 归一化会处理极值

```python
# 修改前
wpcp = wpct.clip(lower=0.0)
wmaxpct = (wpcp.rolling(120, min_periods=1).max() / 0.30).clip(0.0, 1.0)
# 修改后
wpcp = wpct.clip(lower=0.0)
wmaxpct = wpcp.rolling(120, min_periods=1).max()  # ratio 口径，不截断
```

**备选**: 如果需要严格按设计读取 `max_pct_chg_history` 字段（百分数口径），则需从 raw_daily 取 pct_chg 列的历史最大值并 /100。但由于代码架构是 pivot-based rolling，用 pct_change 的 rolling max 等价且更高效。

**依赖**: 与 FIX-P0-01 同批执行
**风险**: 中 — 移除天花板后极端值会更大，但 zscore 归一化会处理。需验证评分分布不会过度偏移。

---

### FIX-P0-03 + FIX-P0-04 结构因子恢复 trend_continuity_ratio（合并修复）

**问题**: 结构因子缺少 trend_continuity_ratio（被错放到行为因子）
**修复方向**: 以设计为准，修改代码

**改动要点**:
1. 在结构因子计算中引入 trend_continuity_ratio:
   - 已有 `_cu_arr`（连续上涨天数）和 `_tw_arr`（趋势窗口 = adaptive_window/3）
   - 计算: `trend_cont = clip(consecutive_up_days / trend_window, 0, 1)`
   - 需要将其扩展为与宽表兼容的向量

2. 按窗口构建趋势延续宽表:
   ```python
   # 对每个窗口 _w，趋势窗口 = clip(round(_w/3), 10, 40)
   # 用 wuf.rolling(_tw).mean() 作为 trend_continuity 的宽表近似
   w_trend: dict[int, pd.DataFrame] = {}
   for _w in (20, 60, 120):
       _tw = max(10, min(40, round(_w / 3)))
       w_trend[_w] = wuf.rolling(_tw, min_periods=1).mean().clip(0.0, 1.0)
   ```

3. 修改结构因子公式:
   ```python
   # 修改前
   w_str[_w] = 0.7 * _pos + 0.3 * _wbsn
   # 修改后
   w_str[_w] = 0.4 * _pos + 0.3 * w_trend[_w] + 0.3 * _wbsn
   ```

4. 从行为因子中移除 `_trend_comp`（见 FIX-P0-05）

**依赖**: 与 FIX-P0-05 必须同步修改（移出行为因子 + 移入结构因子）
**风险**: 中 — 结构因子语义变化较大，需回测验证评分分布

---

### FIX-P0-05 行为因子恢复设计组件（limit_up_flag + pct_chg_norm）

**问题**: 行为因子组件和权重全部偏离设计
**修复方向**: 以设计为准，修改代码

**改动要点**:
1. **移除 trend_comp**（已移入结构因子）

2. **引入 limit_up_flag**: 利用 FIX-P1-02 读取的真实涨停数据
   ```python
   # is_limit_up: 布尔向量 → 1.0
   # is_touched_limit_up: 布尔向量 → 0.7
   # 其他 → 0.0
   _lu_flag = np.where(_is_lu_real, 1.0, np.where(_is_tlu_real, 0.7, 0.0))
   ```

3. **修正 pct_chg_norm**: 映射范围从 ±10% 扩展到 ±20%，使用日间涨跌幅而非日内收益率
   ```python
   # 修改前: wpcomp = ((wret + 0.1) / 0.2).clip(0.0, 1.0)  # 日内±10%
   # 修改后: 使用 wpct（日间 pct_change ratio）
   wpcomp = ((wpct + 0.20) / 0.40).clip(0.0, 1.0)  # 日间±20%
   ```

4. **修正权重**:
   ```python
   # 修改前
   _beh_raw = 0.4 * _vq + 0.4 * _pc + 0.2 * _trend_comp
   # 修改后
   _beh_raw = 0.4 * _vq + 0.3 * _pc + 0.3 * _lu_flag
   ```

**依赖**: FIX-P1-02（需要真实涨停数据）+ FIX-P0-03/04（trend_comp 移出）
**风险**: 中 — limit_up_flag 是稀疏信号（多数日无涨停），需验证不会导致行为因子分布偏移

---

### FIX-P0-06 恢复完整 volume_quality 计算

**问题**: volume_quality 退化为简单量比
**修复方向**: 以设计为准，修改代码

**改动要点**:
```python
# 修改前
wvq = (wv / _wva_safe).clip(0.0, 2.0) / 2.0

# 修改后 — 三子组件复合
_vol_ratio_norm = (wv / _wva_safe / 3.0).clip(0.0, 1.0)            # 量比归一化
# turnover_norm 需从 FIX-P1-01 获取的真实 turnover_rate
# _turnover_norm = (turnover_rate_wide / 12.0).clip(0.0, 1.0)
_intraday_retention = ((wc - wl) / (wh - wl).clip(lower=EPS)).clip(0.0, 1.0)
wvq = (0.60 * _vol_ratio_norm + 0.25 * _turnover_norm + 0.15 * _intraday_retention).clip(0.0, 1.0)
```

注意: `turnover_norm` 需要将 `raw_daily_basic` 的 turnover_rate 宽表化（pivot），这需要在数据加载阶段（FIX-P1-01）同时处理历史 turnover_rate 的 pivot。

**依赖**: FIX-P1-01（需要真实 turnover_rate 的历史宽表）
**风险**: 中 — 新增 intraday_retention 需要宽表 wh/wl/wc 的逐日数据，已有

---

### FIX-P0-07 breakout_ref 随自适应窗口切换

**问题**: breakout_ref 始终取 max(20d_prev, 60d_prev)，不随窗口变化
**修复方向**: 以设计为准，修改代码

**改动要点**:
1. 新增 `high_120d_prev` 计算:
   ```python
   wh120p = whs1.rolling(120, min_periods=1).max()
   ```

2. 为每个窗口使用对应的 breakout_ref:
   ```python
   w_breakout_ref: dict[int, pd.DataFrame] = {
       20: wh20p,
       60: wh60p,
       120: wh120p,
   }
   ```

3. 在结构因子循环中使用窗口对应的 breakout_ref:
   ```python
   for _w in (20, 60, 120):
       _br = w_breakout_ref[_w]
       _bs = (wc - _br) / _br.abs().clip(lower=EPS)  # 简单比率（见 FIX-P0-08）
       w_str[_w] = 0.4 * _pos + 0.3 * w_trend[_w] + 0.3 * _bs
   ```

**依赖**: 与 FIX-P0-08 同步修改
**风险**: 低 — 仅增加一个 rolling 计算和窗口分派

---

### FIX-P0-08 突破强度改为设计的简单比率

**问题**: 代码对 breakout_strength 做了额外 clip + 线性映射
**修复方向**: 以设计为准，修改代码

**改动要点**:
```python
# 修改前
_wbsn = (((wc - _wbr_s) / _wbr_abs).clip(-0.2, 0.2) + 0.2) / 0.4
_wbsn = _wbsn.clip(0.0, 1.0)

# 修改后 — 简单比率，允许负值，由 zscore 处理
# 在每个窗口的循环内:
_bs = (wc - _br) / _br.abs().clip(lower=EPS)
# _bs 不做 clip，直接进入 structure_raw 公式
```

**注意**: 去掉 clip 后 breakout_strength 可能出现较大的极值（如 +50% 突破）。这些极值会被 zscore 归一化处理（映射到 [-3σ, +3σ] → [0, 100]），不需要额外截断。

**依赖**: 与 FIX-P0-07 合并实现
**风险**: 低 — zscore 本身具备极值处理能力

---

## 第三批：输出模型补全

### FIX-P2-01 主表补齐缺失字段

**问题**: 缺少 stock_name, industry_code, entry, stop, target
**修复方向**: 以设计为准，修改代码

**改动要点**:
1. `stock_name`: 从 `raw_stock_basic` 或 `raw_daily` 的 name 列获取（如果已有）
2. `industry_code`: 从 `raw_stock_basic` 获取（需新增查询）
3. `entry/stop/target`: 代码中已计算 `_entry/_stop/_tgt`，只是没写入 frame。直接添加到输出 DataFrame:
   ```python
   frame["entry"] = np.round(_entry, 4)
   frame["stop"] = np.round(_stop, 4)
   frame["target"] = np.round(_tgt, 4)
   ```

**关于别名字段**: `pas_score` / `pas_direction` 可保留（向后兼容），但不作为契约字段。

**依赖**: 无
**风险**: 低 — 新增字段，不影响已有计算

---

### FIX-P2-02 因子中间表补齐字段

**问题**: 设计要求 18 字段，代码仅写 6 个
**修复方向**: 以设计为准，修改代码

**改动要点**: 在 `factor_frame` 构造中补齐:
- 原始因子值: limit_up_count_120d, new_high_count_60d, max_pct_chg_history, price_position, consecutive_up_days, consecutive_down_days, breakout_strength, volume_ratio, volume_quality
- zscore 参数快照: bull_gene_mean/std, structure_mean/std, behavior_mean/std

多数变量在第二批修复后已计算完毕，仅需写入。

**依赖**: 第二批修复完成后（变量可用）
**风险**: 低 — 仅增加字段写入

---

### FIX-P2-03 实现 pas_opportunity_log 表

**问题**: 等级变化日志表未实现
**修复方向**: 以设计为准，新增代码

**改动要点**:
1. 在持久化阶段，读取前一交易日的 `stock_pas_daily` 获取 `prev_grade`
2. 比较当日 `opportunity_grade` 与 `prev_grade`，确定 `grade_change`
3. 写入 `pas_opportunity_log` 表

**依赖**: 无
**风险**: 低 — 新增功能，不影响已有逻辑。但需考虑首次运行（无前一日数据）的边界情况。

---

## 第四批：文档与基线

### FIX-P3-01 更新模块 Docstring

**问题**: 因子命名为早期概念（momentum/volume/pattern）
**修复方向**: 以设计为准，修改代码

**改动要点**: 修改 `pipeline.py:1-8`:
```python
"""PAS（Price Action Signals）个股价格行为信号流水线。

三因子评分 + 方向判定 + 机会等级 + 风险收益比。
三因子：
  1. bull_gene_score   — 牛股基因（涨停频率 + 新高频率 + 历史最大涨幅）
  2. structure_score   — 结构位置（价格位置 + 趋势延续 + 突破强度）
  3. behavior_score    — 行为确认（放量质量 + 涨跌幅 + 涨停确认）

输出: stock_pas_daily 表 + pas_factor_intermediate 表。
"""
```

**依赖**: 无
**风险**: 无

---

### FIX-P3-02 落地 Z-Score baseline parquet 机制

**问题**: baseline 从历史数据内联计算，未持久化
**修复方向**: 以设计为准，新增代码

**改动要点**:
1. 每日计算完成后，将三因子的 mean/std 写入 `${DATA_PATH}/config/pas_zscore_baseline.parquet`
2. 下次运行时，优先加载该文件；如果可用历史 >= 120 日则用实时计算覆盖
3. 首次部署时，如果 parquet 文件不存在且历史不足 120 日，使用离线预置 baseline（或 mean=0, std=1 的保守默认值，产出 50 分中性评分）

**依赖**: 第二批修复完成（因子计算正确后再持久化 baseline）
**风险**: 低 — 增量功能，原有 inline 计算作为 fallback

---

## 修复依赖关系图

```
FIX-P1-01 (raw_daily_basic)  ──┐
                                ├──→ FIX-P0-06 (volume_quality)
FIX-P1-02 (raw_limit_list)   ──┤
                                ├──→ FIX-P0-05 (行为因子 limit_up_flag)
                                │
                                └──→ FIX-P0-01 + P0-02 (牛股基因权重+计算)

FIX-P0-03 + P0-04 (结构因子 trend) ←──→ FIX-P0-05 (行为因子移除 trend)
                                              ↑
FIX-P0-07 + P0-08 (breakout_ref 窗口化) ──────┘

以上全部完成后:
  → FIX-P2-01 (主表字段)
  → FIX-P2-02 (中间表字段)
  → FIX-P2-03 (opportunity_log)
  → FIX-P3-01 (docstring)
  → FIX-P3-02 (baseline parquet)
```

---

## 风险评估与回测建议

### 修复后预期变化
1. **评分分布将发生变化**: 三因子公式全部修正后，历史评分基线将偏移。建议修复后在全量历史数据上重新跑一次 PAS，对比修复前后的评分分布。
2. **S/A 级标的集合将变化**: 由于结构因子新增趋势延续维度、行为因子新增涨停确认维度，筛选出的高评分标的将不同。
3. **有效风险收益比将变化**: volume_quality 恢复完整计算后，liquidity_discount 折扣更精确。

### 建议的验证步骤
1. 修复完成后，选取 3-5 个历史交易日全量运行
2. 对比修复前后: 评分分布直方图、S/A 级标的重合度、风险收益比分布
3. 人工抽检 10 只标的，验证因子中间值与设计公式一致
4. 运行 §9.5 契约漂移检查脚本，确认输出合法性

---

## 待决策项（需人工确认）

| 编号 | 待决策 | 选项 | 建议 |
|------|--------|------|------|
| D-01 | max_pct_chg_history 是否需要覆盖全历史（而非仅 120 日）| A. 全历史 B. 120 日 | 建议 B（120 日），与数据加载窗口一致且避免引入过早历史 |
| D-02 | 别名字段 pas_score/pas_direction 是否保留 | A. 保留 B. 移除 | 建议 A 暂时保留，避免破坏可能的下游依赖 |
| D-03 | pas_opportunity_log 是否在本批次实现 | A. 本批次 B. 后续 | 建议 B 后续——核心因子修复优先 |
