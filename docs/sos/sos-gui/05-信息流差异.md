# 05 信息流差异

**对比来源**: gui-information-flow.md v3.2.0 vs 代码实际数据流

---

## 一、数据流总览架构偏差

### 设计的 3 层数据服务架构

```
L3/L4 数据层 → DataService (内含 DataRepo + CacheService + FilterSvc + FormatterSvc) → Page Controllers → Components → 输出层
```

### 代码的实际架构

```
DuckDB → DataService (直连 SQL + 内联格式化) → dashboard.py (7 个渲染函数) → Streamlit st.xxx 直调
```

### 差异对照

| 层次 | 设计 | 代码 |
|------|------|------|
| 数据访问 | DataRepository 抽象层 | DuckDB 直连裸 SQL |
| 缓存 | CacheService (get/set/build_key) | 无缓存（每次查库） |
| 过滤 | FilterService (apply_filters/apply_sort) | SQL ORDER BY（无过滤） |
| 格式化 | FormatterService | formatter.py 独立函数 ✅ |
| 页面控制 | 7 个 PageController 类 | 7 个 `_render_xxx()` 函数 |
| 组件 | 6 个可复用 Component | 内联 st.metric/st.dataframe |

---

## 二、CP-09 最小闭环流程偏差

### 设计的 CP-09 闭环

```
GUI 启动
  → DataService.run_minimal(trade_date)
    → get_dashboard_data(trade_date, top_n)
    → get_integrated_page_data(trade_date, filters, page=1)
    → render Dashboard
    → render IntegratedPage
  → 输出: GuiRunResult(rendered_pages, data_state, freshness_summary)
```

### 代码的实际流程

```
CLI: eq gui --date YYYYMMDD
  → app.py: run_gui()
    → 模式 1 (export_mode="daily-report"):
        读 DuckDB metrics → 写 MD/JSON artifacts → 返回 GuiRunResult(export产物)
    → 模式 2 (launch_dashboard=True):
        subprocess 启动 Streamlit → dashboard.py:main()
          → 7 个 Tab 并行渲染
          → 返回 GuiRunResult(dashboard_url)
```

### 关键差异

| 设计要求 | 代码实现 |
|----------|----------|
| `DataService.run_minimal()` 闭环入口 | 不存在 |
| 渲染结果含 `data_state` | 无数据状态跟踪 |
| 渲染结果含 `freshness_summary` | 无真实新鲜度 |
| 仅渲染 Dashboard + Integrated | 一次性渲染全部 7 页 |
| GuiRunResult 反映渲染状态 | GuiRunResult 反映导出/启动状态 |

---

## 三、Dashboard 数据流偏差

### 设计的 5 步流程

```
1. DataService.get_dashboard_data()
2. 并行查询: repo.get_mss_panorama() + repo.get_irs_industry_daily() + repo.get_integrated_recommendation()
3. 数据转换: format_temperature + format_cycle + format_integration_mode + resolve_filter_config + apply_filters + apply_sort + get_freshness_meta
4. 构建 DashboardData
5. 渲染组件: TemperatureCard + CycleBadge + RecommendationTable + IndustryRankTable
```

### 代码的实际流程

```
1. DataService.get_dashboard_data()
2. 串行查询: 3 个 SQL (mss_panorama + integrated_recommendation + irs_industry_daily)
3. 数据转换: temperature_color + cycle_label + integration_mode_badge + build_filter_preset_badges
   ❌ 缺失: resolve_filter_config, apply_filters, apply_sort
   ❌ 缺失: get_freshness_meta（用 now() 伪造）
4. 构建 DashboardData ✅
5. 渲染: st.metric + st.dataframe 直调（无组件封装）
```

### 缺失的转换步骤

- ❌ `resolve_filter_config()` → 未从配置解析阈值
- ❌ `apply_filters()` → 推荐未按 dashboard_min_score 过滤
- ❌ `apply_sort()` → 仅 SQL ORDER BY（无次排序）
- ❌ `get_freshness_meta()` → data_asof 伪造

---

## 四、分页页面数据流偏差（PAS/Integrated）

### 设计的 9 步流程

```
1. 解析请求参数
2. 检查缓存 (build_cache_key → get_cached)     ← ❌ 缺失
3. 查询数据 (repo.get_stock_pas_daily)
4. 应用过滤 (apply_filters)                     ← ❌ 缺失
5. 应用排序 (apply_sort)                         ← ⚠️ 仅主排序
6. 分页 (paginate)                               ← ✅ 实现
7. 数据转换 (format_xxx)                         ← ✅ 实现
8. 设置缓存 (set_cached)                         ← ❌ 缺失
9. 返回 PageData                                 ← ✅ 实现
```

### 代码的实际流程

```
1. SQL 查询全量数据
2. Row mapper 转换
3. 手动分片 (start:end)
4. 返回 PageData
```

缺失步骤：缓存检查/设置（步骤 2/8）、过滤（步骤 4）

---

## 五、用户交互序列偏差

### 设计的 5 方交互

```
User → UI → DataSvc → Cache → Repo
  访问页面 → getData → check cache → miss → query repo → data → set_cache → formatted → 渲染
```

### 代码的实际交互

```
User → Streamlit → DataService → DuckDB
  访问Tab → _render_xxx() → svc.get_xxx() → SQL → 渲染
```

缓存层完全不参与交互流程。

---

## 六、导出流程偏差

### 设计: 用户主动触发的交互式导出

```
用户点击 [导出CSV] → 获取筛选条件 → 查询全量数据 → 构建列配置 → export_to_csv → .reports/gui/xxx.csv → 触发下载
```

### 代码: CLI 命令触发的批量导出

```
eq gui --export daily-report → 读 DuckDB metrics → 写 artifacts/spiral-s5/{date}/ → 返回 path
```

两者是完全不同的导出范式：
- 设计 = 交互式按需导出（在 Streamlit 中点击按钮）
- 代码 = 批量非交互导出（在 CLI 中运行命令）

---

## 七、推荐原因联动流（完全未实现）

### 设计 (§3.3)

```
用户点击推荐项(stock_code)
  → DataService.get_recommendation_reason_panel(stock_code, trade_date)
    → read signal_attribution (L4)
    → read daily_report.risk_summary (L4)
    → read live_backtest_deviation (L4)
  → RecommendationReasonPanel
  → Integrated 页面侧边栏展示
```

### 代码

完全不存在此流程。Integrated 页面仅展示 dataframe，无点击联动。

---

## 急救方案

| 信息流缺失 | 优先级 | 方案 |
|------------|--------|------|
| 缓存交互流 | P0 | 引入 st.cache_data 或会话级 dict 缓存 |
| 过滤交互流 | P0 | 在 DataService 查询中加入 WHERE 条件 |
| CP-09 闭环流 | P0 | 新增 run_minimal 方法 |
| data_asof 真实来源 | P0 | 从 DB 查询最新 trade_date 作为 data_asof |
| 交互式导出流 | P1 | 在 Streamlit 中添加下载按钮 |
| 推荐原因联动流 | P2 | 依赖 L4 数据就绪 |
| 次排序逻辑 | P1 | SQL ORDER BY 补齐 |
