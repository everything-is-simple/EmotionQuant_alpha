# P0 逻辑错误：代码计算逻辑与设计相悖

**严重等级**: P0（直接影响算法正确性，必须修复）
**影响范围**: market_snapshot / industry_snapshot → MSS / IRS / PAS → 全链路

---

## P0-1：rise_count / fall_count 计算口径错误

### 问题描述

设计要求使用 TuShare 提供的 `pct_chg`（涨跌幅，基于前收盘价），代码使用的是 `(close - open) / open`（日内涨跌幅）。

两者的语义完全不同：
- `pct_chg = (close - pre_close) / pre_close × 100` — **日间变化**，这是 A 股市场的标准涨跌幅定义
- `(close - open) / open` — **日内变化**，跳空高开后微跌仍可能被判为"跌"

### 设计原文

> data-layer-algorithm.md §3.1:
> - rise_count: 上涨家数（pct_chg > 0）
> - fall_count: 下跌家数（pct_chg < 0）
> - flat_count: 平盘家数（abs(pct_chg) <= flat_threshold）

### 代码现状

```python
# src/data/l2_pipeline.py 第 100-116 行
pct = (working["close"] - working["open"]) / working["open"].replace(0, pd.NA)
pct = pct.fillna(0.0)
...
rise_count=int((working["close"] > working["open"]).sum()),
fall_count=int((working["close"] < working["open"]).sum()),
flat_count=int((pct.abs() <= flat_threshold_ratio).sum()),
```

### 具体后果

假设某股票：前收 10.00，今开 10.50（跳空高开 5%），今收 10.30
- 按设计（pct_chg）：涨 3% → 计入 rise_count ✓
- 按代码（close vs open）：跌 1.9% → 计入 fall_count ✗

在跳空行情频繁的市场中，这会导致 rise/fall 统计严重失真。

### 修复方案

**方向**：修改 `l2_pipeline.py`，使用 raw_daily 中的 `pct_chg` 字段（TuShare 已提供）。

修复要点：
1. 在 `_build_market_snapshot()` 中，使用 `daily["pct_chg"]` 而非自行计算 pct
2. 若 `pct_chg` 列不存在（如模拟数据），回退为 `(close - pre_close) / pre_close * 100`
3. 若 `pre_close` 也不存在，再回退为 `(close - open) / open * 100` 并标记 `data_quality=degraded`
4. 同步修复 `_build_industry_snapshot_sw31()` 和 `_build_industry_snapshot_all()` 中的同类问题
5. 修复 `SimulatedTuShareClient` 的 `daily` 返回，补齐 `pre_close`、`change`、`pct_chg` 字段

### 涉及文件

- `src/data/l2_pipeline.py` — 主修改
- `src/data/fetcher.py` (SimulatedTuShareClient) — 补齐字段
- 相关测试文件

---

## P0-2：strong_up / strong_down 阈值错误

### 问题描述

设计定义大涨/大跌阈值为 **5%**，代码使用 **3%**。

### 设计原文

> data-layer-algorithm.md §3.1:
> - strong_up_count: 大涨家数（pct_chg > 5%）
> - strong_down_count: 大跌家数（pct_chg < -5%）

### 代码现状

```python
# src/data/l2_pipeline.py 第 117-118 行
strong_up_count=int((pct >= 0.03).sum()),    # 3% 而非 5%
strong_down_count=int((pct <= -0.03).sum()),  # -3% 而非 -5%
```

注意：这里还有双重问题 —— 即使阈值改为 5%，基数 `pct` 也是错误的（见 P0-1）。

### 修复方案

**方向**：修正阈值为 5%，同时修正计算基数为 `pct_chg`。

修复要点：
1. 阈值改为 `pct_chg > 5.0`（注意 TuShare 的 pct_chg 单位是百分数，5 表示 5%）
2. 如果 P0-1 的回退方案使用 ratio（0-1），则阈值为 `0.05`
3. 保持与 P0-1 修复后的 pct 基数一致

### 涉及文件

- `src/data/l2_pipeline.py`

---

## P0-3：touched_limit_up 缺失炸板（Z）统计

### 问题描述

设计要求 `touched_limit_up` 包含封板（U）和炸板（Z），代码直接复制了 `limit_up_count`（仅 U）。

### 设计原文

> data-layer-algorithm.md §3.1:
> - touched_limit_up: 曾涨停（含炸板）家数
>
> data-layer-data-models.md §3.1:
> - touched_limit_up: 曾涨停家数 | limit ∈ {'U', 'Z'}（当日触及涨停总数）

### 代码现状

```python
# src/data/l2_pipeline.py 第 121 行
touched_limit_up=limit_up_count,  # 直接复制，遗漏 Z
```

### 修复方案

**方向**：增加对 `Z`（炸板）类型的统计。

修复要点：
1. 在 limit_list 中同时统计 `limit == 'U'` 和 `limit == 'Z'` 的记录
2. `touched_limit_up = count(U) + count(Z)`
3. 注意字段名问题（见 P1-3 limit vs limit_type）—— 此修复需与 P1-3 一起做

### 涉及文件

- `src/data/l2_pipeline.py`

---

## P0-4：amount_volatility 算法错误

### 问题描述

设计要求计算成交额相对 20 日均值的偏离率，代码只算了当日全市场成交额的标准差。

### 设计原文

> data-layer-data-models.md §3.1:
> - amount_volatility: 成交额相对20日均值的波动率 | (amount - ma20(amount))/ma20(amount)

### 代码现状

```python
# src/data/l2_pipeline.py 第 123 行
amount_volatility=float(working["amount"].std(ddof=0)),
```

`std()` 计算的是当日所有股票成交额的横截面标准差，与设计要求的时间序列偏离率完全不是一个东西。

### 修复方案

**方向**：实现 20 日成交额均值的偏离率计算。

修复要点：
1. 需要读取近 20 个交易日的 market_snapshot（或 raw_daily 汇总），获取历史 total_amount
2. 计算 `ma20_amount = mean(近20日 total_amount)`
3. `amount_volatility = (today_total_amount - ma20_amount) / ma20_amount`
4. 冷启动场景（不足 20 日数据）：标记 `data_quality=cold_start`，amount_volatility 设为 0.0

注意：此修复需要历史数据支持，在初始回填阶段前 20 个交易日的值为 cold_start。

### 涉及文件

- `src/data/l2_pipeline.py`
- 可能需要新增 DuckDB 查询逻辑读取历史 market_snapshot

---

## P0-5：行业估值聚合口径错误（PE/PB）

### 问题描述

设计要求"过滤 → Winsorize → 中位数 → 样本不足沿用前值"，代码只做了"替换 0 为 NA → 取均值"。

### 设计原文

> data-layer-algorithm.md §3.2:
> ```python
> valid_pe = industry_daily_basic['pe_ttm']
> valid_pe = valid_pe[(valid_pe > 0) & (valid_pe <= 1000)]
> if len(valid_pe) >= 8:
>     pe_q01, pe_q99 = valid_pe.quantile([0.01, 0.99])
>     industry_pe_ttm = valid_pe.clip(lower=pe_q01, upper=pe_q99).median()
> else:
>     industry_pe_ttm = load_prev_industry_value(industry_code, "industry_pe_ttm")
> ```
>
> data-layer-data-models.md §3.2:
> 估值聚合口径（IRS 对齐）：先过滤 pe_ttm <= 0，再做 1%-99% Winsorize，最后取行业中位数；样本不足 8 只时沿用前值。

### 代码现状

```python
# src/data/l2_pipeline.py 第 449-455 行
if not basic_working.empty:
    basic_subset = basic_working[basic_working["industry_code"].astype(str) == industry_code]
    industry_pe_ttm = float(basic_subset["pe_ttm"].replace(0.0, pd.NA).mean() or 0.0)
    industry_pb = float(basic_subset["pb"].replace(0.0, pd.NA).mean() or 0.0)
else:
    industry_pe_ttm = 0.0
    industry_pb = 0.0
```

差异：
- 未过滤 `pe_ttm <= 0`（仅替换了 0.0，负值仍参与计算）
- 未过滤 `pe_ttm > 1000`（极端异常值参与计算）
- 使用 `mean()` 而非 `median()`
- 无 1%-99% Winsorize
- 样本不足时直接返回 0.0 而非沿用前值

### 修复方案

**方向**：严格按设计实现四步估值聚合。

修复要点：
1. `valid_pe = pe_ttm[(pe_ttm > 0) & (pe_ttm <= 1000)]`
2. `valid_pb = pb[pb > 0]`
3. 样本 >= 8 时：`quantile([0.01, 0.99])` → `clip()` → `median()`
4. 样本 < 8 时：从 DuckDB 读取该行业上一交易日的 industry_pe_ttm / industry_pb
5. 冷启动（无前值）：设为 0.0 并标记 data_quality

### 涉及文件

- `src/data/l2_pipeline.py`
- 可能需要新增查询 industry_snapshot 前值的逻辑
