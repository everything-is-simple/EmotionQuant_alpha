# P2 路径与结构：存储路径与模块组织偏差

**严重等级**: P2（不影响计算正确性，但影响可维护性和设计-代码一致性）
**影响范围**: 文件存储布局、模块组织、外部工具集成

---

## P2-1：Parquet 存储路径多了 l1/l2 层级

### 问题描述

设计文档定义的 Parquet 存储路径与代码实际路径不一致。

| 层 | 设计路径 | 代码实际路径 |
|----|---------|-------------|
| L1 | `${DATA_PATH}/parquet/daily/{date}.parquet` | `${parquet_path}/l1/raw_daily/{date}.parquet` |
| L1 | `${DATA_PATH}/parquet/limit_list/{date}.parquet` | `${parquet_path}/l1/raw_limit_list/{date}.parquet` |
| L2 | 仅存 DuckDB（无 parquet 规定） | `${parquet_path}/l2/market_snapshot/{date}.parquet` |

差异点：
1. 代码在 parquet 路径下增加了 `/l1/`、`/l2/` 子层级
2. 目录名使用 `raw_daily` 而非设计中的 `daily`
3. 设计未规定 L2 数据需要 Parquet 副本，代码额外写了 Parquet

### 代码位置

```python
# src/data/repositories/base.py 第 142 行
self.parquet_root = Path(self.config.parquet_path) / "l1"

# src/data/l2_pipeline.py 第 708 行
parquet_root = Path(config.parquet_path) / "l2"
```

### 分析

代码的分层路径（l1/l2）实际上比设计更清晰：
- 避免了 L1 和 L2 的 parquet 文件混在同一目录
- `raw_daily` 比 `daily` 更明确表示这是原始数据

L2 额外写 Parquet 也有合理性——便于离线审计和跨工具访问。

### 修复方案

**方向**：反向更新设计文档，认可代码的分层路径。

修复要点：
1. 更新 `data-layer-algorithm.md` §2.3 的存储格式图：
   - `${DATA_PATH}/parquet/l1/raw_daily/` 替代 `${DATA_PATH}/parquet/daily/`
   - 同理修改其他 7 个 L1 目录
2. 补充 L2 Parquet 存储路径说明（标注为"审计副本，非主存储"）
3. 更新 `data-layer-api.md` §11.2 的 DuckDB + Parquet 存储结构图

### 涉及文件

- `docs/design/core-infrastructure/data-layer/data-layer-algorithm.md`
- `docs/design/core-infrastructure/data-layer/data-layer-api.md`

---

## P2-2：Ops 表存储在主库而非独立 ops.duckdb

### 问题描述

设计要求运维/元数据表（system_config、data_quality_report、data_readiness_gate）存放在独立的 `ops.duckdb`，代码将其全部写入主库 `emotionquant.duckdb`。

### 设计原文（data-layer-api.md §11.2）

> ```
> ${DUCKDB_DIR}/
> ├── emotionquant.duckdb        # 默认主库（L2/L3/L4 + Business Tables）
> └── ops.duckdb                 # 运维元数据
> ```

### 代码现状

```python
# src/data/quality_store.py 中 init_quality_context() 接收的 database_path
# 在 l1_pipeline.py 第 226 行传入的是：
database_path = Path(config.duckdb_dir) / "emotionquant.duckdb"
# ops 表写入了主库
```

### 分析

将 ops 表放在主库的好处：
- 简化部署（只需维护一个数据库文件）
- 减少跨库查询复杂度
- 当前数据量小，分库收益不大

放在独立 ops.duckdb 的好处：
- 主库锁争用减少
- 备份/恢复可以分别操作
- 运维操作不影响业务查询

### 修复方案

**方向**：有两个合理选择。

**选项 A（推荐）**：更新设计文档，承认当前"单库优先"的实现。在设计的"分库触发策略"中补充说明：在主库体积未触发分库阈值前，ops 表与业务表共用主库。

**选项 B**：修改代码，将 ops 表迁移到独立的 `ops.duckdb`。需要修改 `quality_store.py` 的所有数据库连接路径。

当前阶段推荐选项 A——单库足够，未来触发分库再拆分。

### 涉及文件

- `docs/design/core-infrastructure/data-layer/data-layer-api.md` — 更新存储结构说明
- 或 `src/data/quality_store.py` — 取决于选择方向

---

## P2-3：trade_cal 拉取范围（单日 vs 年度）

### 问题描述

设计要求 trade_cal 按年度拉取完整交易日历，代码每次只拉取单日。

### 设计原文（data-layer-algorithm.md §2.1.1）

> | trade_cal | 交易日历 | 年度 |

### 代码现状

```python
# src/data/repositories/trade_calendars.py 第 24-27 行
def fetch(self, *, trade_date: str, fetcher: TuShareFetcher, **_: Any):
    return fetcher.fetch_with_retry(
        "trade_cal",
        {"start_date": trade_date, "end_date": trade_date},  # 只拉单日
    )
```

### 分析

按单日拉取的问题：
- 每个交易日都要调一次 trade_cal API，浪费配额
- 无法判断未来日期是否为交易日
- `pretrade_date`（前一交易日）信息在单日模式下可能不完整

按年度拉取的好处：
- 一次调用获取全年 365 天的交易日历
- 可缓存全年，后续日期无需再拉
- 支持查询任意日期是否为交易日

### 修复方案

**方向**：修改 trade_cal 的拉取策略。

修复要点：
1. 每年初（或首次使用时）拉取当年全年的 trade_cal：`start_date=YYYY0101, end_date=YYYY1231`
2. 后续只在本地缓存不存在时才拉取
3. 与 stock_basic（月度）、index_classify（半年度）的低频节流策略统一管理

### 涉及文件

- `src/data/repositories/trade_calendars.py`
- `src/data/l1_pipeline.py`（调度逻辑）

---

## P2-4：API 模块路径（规划 vs 实际）

### 问题描述

设计文档规划了标准化的模块路径，代码使用了不同的组织结构。

| 设计规划路径 | 代码实际位置 | 说明 |
|-------------|-------------|------|
| `src.data.services.tushare_client.TuShareClient` | `src.data.fetcher.RealTuShareClient` | 类名和路径都不同 |
| `src.data.services.data_fetcher.DataFetcher` | `src.data.fetcher.TuShareFetcher` | 同上 |
| `src.data.services.data_processor.DataProcessor` | `src.data.l2_pipeline` (内嵌函数) | 未独立为类 |
| `src.data.utils.code_converter` | `src.data.l2_pipeline` (内嵌函数) | 同上 |
| `src.data.exceptions` | `src.data.fetcher` + `src.config.exceptions` | 分散在多处 |
| `src.data.repositories.MarketSnapshotRepo` | 不存在 | L2/L3 仓储未实现 |
| `src.data.repositories.IndustrySnapshotRepo` | 不存在 | 同上 |
| `src.data.repositories.StockGeneRepo` | 不存在 | 同上 |
| `src.data.repositories.ResultsRepo` | 不存在 | 同上 |

### 分析

设计中的 API 文档明确注明了"多数仍为规划接口"，所以这些模块路径差异是预期内的。
当前代码的组织方式更加紧凑（fetcher.py 包含客户端+拉取器+重试），在骨架阶段是合理的。

但随着代码增长，建议：
- `DataProcessor` 应该从 `l2_pipeline.py` 中抽出独立模块
- `code_converter` 工具函数应该独立为 `src/data/utils/`
- L2/L3 仓储应按设计规划逐步实现

### 修复方案

**方向**：此项为长期优化，当前无需紧急修改。

建议动作：
1. 在设计文档的"实现状态"章节更新当前实际的模块路径映射
2. 将代码重构纳入后续 Spiral 规划（而非 SOS 急救范围）
3. 优先级低于所有 P0 和 P1 项

### 涉及文件

- `docs/design/core-infrastructure/data-layer/data-layer-api.md` — 更新实现状态
