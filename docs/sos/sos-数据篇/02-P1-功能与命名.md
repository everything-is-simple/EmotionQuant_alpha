# P1 功能与命名：缺失实现与命名不一致

**严重等级**: P1（功能缺失或命名不一致，存在生产隐患）
**影响范围**: L2 快照字段完整性、真实数据适配、数据模型一致性

---

## P1-1：多个快照字段未计算（stub=0）

### 问题描述

以下字段在 `MarketSnapshot` 数据模型中已定义，但 `l2_pipeline.py` 从未计算，始终默认为 0。

| 字段 | 设计要求 | 代码现状 | 缺失原因 |
|------|---------|---------|---------|
| new_100d_high_count | 比较 close 与近 100 日最高 close | 始终 0 | 需要 100 日历史数据 |
| new_100d_low_count | 比较 close 与近 100 日最低 close | 始终 0 | 同上 |
| continuous_limit_up_2d | 连续 2 日涨停计数 | 始终 0 | 需要多日涨停历史 |
| continuous_limit_up_3d_plus | 连续 3+ 日涨停计数 | 始终 0 | 同上 |
| continuous_new_high_2d_plus | 连续 2 日+新高计数 | 始终 0 | 需要多日新高历史 |
| high_open_low_close_count | 高开低走计数 | 始终 0 | 需要 pre_close 字段 |
| low_open_high_close_count | 低开高走计数 | 始终 0 | 同上 |
| yesterday_limit_up_today_avg_pct | 昨涨停今平均涨幅 | 始终 0.0 | 需要前一交易日涨停列表 |

### 设计原文（data-layer-data-models.md §3.1 节选）

> - high_open_low_close_count: 高开低走计数 | open>pre_close*1.02 且 close<open*0.94
> - yesterday_limit_up_today_avg_pct: 昨涨停今平均涨幅 | 聚合计算
> - new_100d_high_count: 100日新高数 | close > max(close, 100d)

### 修复方案

**方向**：分两阶段实现。

**阶段 A（当前圈可做）**：
1. `high_open_low_close_count` / `low_open_high_close_count` — 修复 P0-1（补齐 pre_close）后即可实现
2. `yesterday_limit_up_today_avg_pct` — 需读取前一交易日的 raw_limit_list，复杂度中等

**阶段 B（需历史数据积累后）**：
1. `new_100d_high_count` / `new_100d_low_count` — 需要 100 日 raw_daily 历史
2. `continuous_limit_up_*` — 需要多日 raw_limit_list 历史
3. `continuous_new_high_2d_plus` — 需要多日新高计算历史

**同步动作**：在设计文档 `data-layer-algorithm.md` 的"实现状态"章节明确标注这些字段当前为 `stub=0`，并注明预计实现阶段。

### 涉及文件

- `src/data/l2_pipeline.py` — 实现计算
- `docs/design/core-infrastructure/data-layer/data-layer-algorithm.md` — 更新实现状态

---

## P1-2：SimulatedTuShareClient 缺少关键字段

### 问题描述

模拟客户端的 `daily` 接口返回数据缺少设计中定义的 3 个关键字段：`pre_close`、`change`、`pct_chg`。

### 设计原文（data-layer-data-models.md §2.1）

> raw_daily 日线行情字段：ts_code, trade_date, open, high, low, close, **pre_close**, **change**, **pct_chg**, vol, amount

### 代码现状

```python
# src/data/fetcher.py SimulatedTuShareClient._daily() 返回的字段
# ts_code, stock_code, trade_date, open, high, low, close, vol, amount
# 缺失: pre_close, change, pct_chg
```

### 后果

- 所有依赖 `pct_chg` 的计算在模拟环境下无法正确运行
- 测试无法覆盖真实数据路径
- P0-1 的修复前置依赖此项

### 修复方案

**方向**：在 SimulatedTuShareClient 中补齐字段。

修复要点：
```
pre_close = open_price * 0.98  # 模拟前收盘价
change = close_price - pre_close
pct_chg = round(change / pre_close * 100, 4)
```

### 涉及文件

- `src/data/fetcher.py` (SimulatedTuShareClient)

---

## P1-3：涨跌停字段名 limit vs limit_type（生产隐患）

### 问题描述

设计和 TuShare 真实 API 使用字段名 `limit`（值为 U/D/Z），代码中使用 `limit_type`。

这意味着：
- 模拟环境下能正常工作（SimulatedTuShareClient 返回 `limit_type`）
- **真实生产环境下会全部匹配不到**（TuShare 返回 `limit`，代码检查 `limit_type`）

### 设计原文（data-layer-data-models.md §2.3）

> | limit | VARCHAR(10) | 涨跌停类型 U/D/Z | TuShare |

### 代码现状

```python
# src/data/fetcher.py SimulatedTuShareClient 第 164 行
"limit_type": "U",

# src/data/l2_pipeline.py 第 104-106 行
if not limit_rows.empty and "limit_type" in limit_rows.columns:
    limit_up_count = int((limit_rows["limit_type"].astype(str) == "U").sum())
```

### 修复方案

**方向**：双管齐下。

修复要点：
1. **RealTuShareClient**（`_normalize_fields`）：将 TuShare 返回的 `limit` 字段统一重命名为代码中使用的名称
2. **l2_pipeline.py**：优先检查 `limit` 字段，回退检查 `limit_type`
3. **SimulatedTuShareClient**：将 `limit_type` 改为 `limit`（与 TuShare 真实返回对齐）
4. 或者统一全部改为 `limit`（推荐，与设计和 TuShare 原始字段一致）

**推荐方案**：全部对齐到设计文档的 `limit`，因为这是 TuShare 的原始字段名。

### 涉及文件

- `src/data/fetcher.py` — SimulatedTuShareClient 改字段名
- `src/data/l2_pipeline.py` — 改检查字段名
- 相关测试文件

---

## P1-4：TradeCalendar 字段名 cal_date vs trade_date

### 问题描述

设计文档定义 raw_trade_cal 表的日期字段为 `cal_date`，代码模型使用 `trade_date`。

### 设计原文（data-layer-data-models.md §2.8）

> | cal_date | VARCHAR(8) | 日期 YYYYMMDD |

### 代码现状

```python
# src/data/models/entities.py 第 29 行
class TradeCalendar:
    trade_date: str   # 设计是 cal_date
    is_open: int
    pretrade_date: str = ""
```

### 分析

TuShare 的 trade_cal 接口实际返回的字段名是 `cal_date`。但 `RealTuShareClient._normalize_fields()` 中有一段逻辑会将 `cal_date` 补写为 `trade_date`（第 340-343 行）。所以这是有意的标准化行为。

### 修复方案

**方向**：此项属于合理的标准化偏差，但需要设计文档与代码保持一致。

两个选择：
- **选项 A（推荐）**：更新设计文档，将 raw_trade_cal 的 `cal_date` 改为 `trade_date`，与代码和其他表的命名统一
- **选项 B**：保留设计的 `cal_date`，修改代码回退到 `cal_date`

推荐选项 A，因为全系统统一使用 `trade_date` 作为日期字段更一致。

### 涉及文件

- `docs/design/core-infrastructure/data-layer/data-layer-data-models.md` — 更新字段名
- 或 `src/data/models/entities.py` — 取决于选择方向

---

## P1-5：IndustrySnapshot 代码多出字段（market_amount_total / style_bucket）

### 问题描述

代码中的 `IndustrySnapshot` 数据模型包含两个设计文档中未定义的字段：

| 字段 | 代码中的用途 | 设计中是否存在 |
|------|-------------|---------------|
| `market_amount_total` | 全市场当日成交额合计 | ❌ 不存在 |
| `style_bucket` | 风格分桶 (value/balanced/growth) | ❌ 不存在 |

### 代码现状

```python
# src/data/models/snapshots.py 第 126-127 行
market_amount_total: float = 0.0
style_bucket: str = "balanced"
```

`style_bucket` 在 `l2_pipeline.py` 中通过 `_assign_style_bucket()` 函数计算，根据 PE+PB 排名分为 value/balanced/growth 三档。

### 分析

这两个字段的存在是合理的：
- `market_amount_total` 用于计算行业成交额占比
- `style_bucket` 为 IRS 提供风格分类依据

但它们不在设计文档中，属于"实现超前于设计"的情况。

### 修复方案

**方向**：反向补入设计文档。

修复要点：
1. 在 `data-layer-data-models.md` §3.2 industry_snapshot 表定义中新增这两个字段
2. 在 `data-layer-algorithm.md` §3.2 补充 style_bucket 的计算逻辑说明
3. 在 `data-layer-information-flow.md` 补充 style_bucket 的数据流向说明

### 涉及文件

- `docs/design/core-infrastructure/data-layer/data-layer-data-models.md`
- `docs/design/core-infrastructure/data-layer/data-layer-algorithm.md`
